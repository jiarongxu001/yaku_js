Warning: value on stack is short, instruction expects byte: ROT in <lambda> on line 5 of yaku-tests/tests/ex24_lambda_fixpoint.tal: ROT DUP ( f* n n ) 
5Warning: value on stack is byte, instruction expects short: SWP2 in <lambda> on line 9 of yaku-tests/tests/ex24_lambda_fixpoint.tal: SWP2 DUP2 ( n n-1 f* f* ) JSR2 MUL JMP2r } STH2r 
43210*Warning: value on stack is byte, instruction expects short: POP2 in <lambda> on line 7 of yaku-tests/tests/ex24_lambda_fixpoint.tal: ?{ #2a18 DEO POP POP2 #01 JMP2r } 
xreal 0.10
user 0.03
sys 0.02
            62537728  maximum resident set size
                   0  average shared memory size
                   0  average unshared data size
                   0  average unshared stack size
                2261  page reclaims
                2023  page faults
                   0  swaps
                   0  block input operations
                   0  block output operations
                   0  messages sent
                   0  messages received
                   0  signals received
                  20  voluntary context switches
                 803  involuntary context switches
           647389466  instructions retired
           239399372  cycles elapsed
            31937960  peak memory footprint
Possible error in comments, probably missing space around paren:
	bit_idx)

Error: <   |0000    @idx $2 @jj $2  @n_pages $2  @byte_idx $2  @bit_idx $2  @byte $1  |0100    test-mask_clear  test-mask_set  test-get_bit  test-clear_bit   test-set_bit   test-alloc_sz_is_free_at_idx  test-claim_alloc_sz_at_idx  test-free_alloc_sz_at_idx  test-malloc  test-free  BRK    @test-mask_clear       { 001d "Test 20 "for 20 "mask_clear(bit_idx) 0a } STH2r print-str      #0000 mask_clear  #fe EQU #30 ADD #18 DEO #0a18 DEO      #0001 mask_clear  #fd EQU #30 ADD #18 DEO #0a18 DEO      #0002 mask_clear  #fb EQU #30 ADD #18 DEO #0a18 DEO      #0003 mask_clear  #f7 EQU #30 ADD #18 DEO #0a18 DEO      #0004 mask_clear  #ef EQU #30 ADD #18 DEO #0a18 DEO      #0005 mask_clear  #df EQU #30 ADD #18 DEO #0a18 DEO      #0006 mask_clear  #bf EQU #30 ADD #18 DEO #0a18 DEO      #0007 mask_clear  #7f EQU #30 ADD #18 DEO #0a18 DEO  JMP2r  @test-mask_set       { 001b "Test 20 "for 20 "mask_set(bit_idx) 0a } STH2r print-str      #0000 mask_set  #01 EQU #30 ADD #18 DEO #0a18 DEO      #0001 mask_set  #02 EQU #30 ADD #18 DEO #0a18 DEO      #0002 mask_set  #04 EQU #30 ADD #18 DEO #0a18 DEO      #0003 mask_set  #08 EQU #30 ADD #18 DEO #0a18 DEO      #0004 mask_set  #10 EQU #30 ADD #18 DEO #0a18 DEO      #0005 mask_set  #20 EQU #30 ADD #18 DEO #0a18 DEO      #0006 mask_set  #40 EQU #30 ADD #18 DEO #0a18 DEO      #0007 mask_set  #80 EQU #30 ADD #18 DEO #0a18 DEO  JMP2r        @test-get_bit       { 0016 "Test 20 "for 20 "get_bit(idx) 0a } STH2r print-str      #01 ;bitmap #0001 ADD2 STA       #80 ;bitmap #0003 ADD2 STA       #02 ;bitmap #0004 ADD2 STA       #60 ;bitmap #0008 ADD2 STA       #04 ;bitmap #000c ADD2 STA       #20 ;bitmap #000d ADD2 STA       #0010 get_bit #00 EQU #000f get_bit #01 EQU AND print-bit nl      #0018 get_bit #01 EQU #0019 get_bit #00 EQU AND print-bit nl      #0026 get_bit #01 EQU #0027 get_bit #00 EQU AND print-bit nl      #0041 get_bit #01 EQU #0042 get_bit #01 EQU AND print-bit nl      #0065 get_bit #01 EQU #0066 get_bit #00 EQU AND print-bit nl      #006a get_bit #01 EQU #006b get_bit #00 EQU AND print-bit nl      #03 ;bitmap #0001 ADD2 STA       #c0 ;bitmap #0003 ADD2 STA       #06 ;bitmap #0004 ADD2 STA       #20 ;bitmap #0008 ADD2 STA       #0c ;bitmap #000c ADD2 STA       #30 ;bitmap #000d ADD2 STA       #0010 get_bit #00 EQU #000f get_bit #01 EQU AND print-bit nl      #0018 get_bit #01 EQU #0019 get_bit #01 EQU AND print-bit nl      #0026 get_bit #01 EQU #0025 get_bit #01 EQU AND print-bit nl      #0041 get_bit #00 EQU #0042 get_bit #01 EQU AND print-bit nl      #0064 get_bit #01 EQU #0065 get_bit #01 EQU AND print-bit nl      #006a get_bit #01 EQU #006b get_bit #01 EQU AND print-bit nl  JMP2r  @test-clear_bit       { 0018 "Test 20 "for 20 "clear_bit(idx) 0a } STH2r print-str      #000f clear_bit #000e clear_bit      #0018 clear_bit #0019 clear_bit      #0026 clear_bit #0027 clear_bit      #0041 clear_bit #0042 clear_bit      #0065 clear_bit #0066 clear_bit      #006a clear_bit #006b clear_bit      #000f get_bit #00 EQU #000e get_bit #00 EQU AND print-bit nl      #0018 get_bit #00 EQU #0019 get_bit #00 EQU AND print-bit nl      #0026 get_bit #00 EQU #0027 get_bit #00 EQU AND print-bit nl      #0041 get_bit #00 EQU #0042 get_bit #00 EQU AND print-bit nl      #0065 get_bit #00 EQU #0066 get_bit #00 EQU AND print-bit nl      #006a get_bit #00 EQU #006b get_bit #00 EQU AND print-bit nl  JMP2r  @test-set_bit       { 0016 "Test 20 "for 20 "set_bit(idx) 0a } STH2r print-str      #000f set_bit #000e set_bit      #0018 set_bit #0019 set_bit      #0026 set_bit #0027 set_bit      #0041 set_bit #0042 set_bit      #0065 set_bit #0066 set_bit      #006a set_bit #006b set_bit      #000f get_bit #000e get_bit EQU print-bit nl      #0018 get_bit #0019 get_bit EQU print-bit nl      #0026 get_bit #0027 get_bit EQU print-bit nl      #0041 get_bit #0042 get_bit EQU print-bit nl      #0065 get_bit #0066 get_bit EQU print-bit nl      #006a get_bit #006b get_bit EQU print-bit nl  JMP2r  @test-alloc_sz_is_free_at_idx       { 002f "Test 20 "for 20 "alloc_sz_is_free_at_idx(idx,alloc_sz) 0a } STH2r print-str         { 0006 "part1 0a } STH2r print-str       #000f #0001 alloc_sz_is_free_at_idx #00 EQU print-bit nl       #000f #0002 alloc_sz_is_free_at_idx #00 EQU print-bit nl       #000f #0004 alloc_sz_is_free_at_idx #00 EQU print-bit nl       #000f #0008 alloc_sz_is_free_at_idx #00 EQU print-bit nl       #000f #0010 alloc_sz_is_free_at_idx #00 EQU print-bit nl       { 0006 "part2 0a } STH2r print-str          #0010 #0001 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0010 #0002 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0010 #0004 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0010 #0008 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0010 #0010 alloc_sz_is_free_at_idx #00 EQU print-bit nl       { 0006 "part3 0a } STH2r print-str          #0011 #0001 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0011 #0002 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0011 #0004 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0011 #0008 alloc_sz_is_free_at_idx #00 EQU print-bit nl       #0011 #0010 alloc_sz_is_free_at_idx #00 EQU print-bit nl       { 0006 "part4 0a } STH2r print-str         #006c #0001 alloc_sz_is_free_at_idx #01 EQU print-bit nl      #006c #0002 alloc_sz_is_free_at_idx #01 EQU print-bit nl      #006c #0004 alloc_sz_is_free_at_idx #01 EQU print-bit nl      #006c #0008 alloc_sz_is_free_at_idx #01 EQU print-bit nl      #006c #0010 alloc_sz_is_free_at_idx #01 EQU print-bit nl  JMP2r  @test-claim_alloc_sz_at_idx       { 002d "Test 20 "for 20 "claim_alloc_sz_at_idx(idx,alloc_sz) 0a } STH2r print-str            ;bitmap LDA2 STH2       { 0006 "part1 0a } STH2r print-str      #0000 ;bitmap STA2        #0000 #0001 claim_alloc_sz_at_idx       ;bitmap LDA DUP print8 ws #80 EQU print-bit nl      #0001 #0002 claim_alloc_sz_at_idx       ;bitmap LDA DUP print8 ws #e0 EQU print-bit nl       #0003 #0003 claim_alloc_sz_at_idx       ;bitmap LDA DUP print8 ws #fc EQU print-bit nl       #0006 #0004 claim_alloc_sz_at_idx       ;bitmap LDA DUP print8 ws      ;bitmap INC LDA DUP print8 ws #ffc0 EQU2 print-bit nl       #000a #0005 claim_alloc_sz_at_idx       ;bitmap LDA DUP print8 ws      ;bitmap INC LDA DUP print8 ws #fffe EQU2 print-bit nl             STH2r ;bitmap STA2      { 0006 "part2 0a } STH2r print-str      #006c #0010 claim_alloc_sz_at_idx      #007c #0010 alloc_sz_is_free_at_idx #01 EQU print-bit nl      #006c #0010 alloc_sz_is_free_at_idx #00 EQU print-bit nl  JMP2r  @test-free_alloc_sz_at_idx        { 002c "Test 20 "for 20 "free_alloc_sz_at_idx(idx,alloc_sz) 0a } STH2r print-str      #006c #0010 free_alloc_sz_at_idx      #007c #0010 alloc_sz_is_free_at_idx print-bit nl      #006c #0010 alloc_sz_is_free_at_idx print-bit nl  JMP2r  @test-malloc  { 0014 "Test 20 "for 20 "malloc(sz) 0a } STH2r print-str  JMP2r  @test-free  { 0013 "Test 20 "for 20 "free(ptr) 0a } STH2r print-str  JMP2r    @reset      #00 .n_allocs STZ      #00 .error STZ         @get-error      .error LDZ       JMP2r        @alloc_sz_is_free_at_idx       #0000 .jj STZ2       &loop          DUP2 .jj LDZ2  SWP2 LTH2           ,&body JCN             ,&done JMP             &body           SWP2           DUP2 DUP2           .jj LDZ2 ADD2 N_PAGES #0001 SUB2 GTH2 ,&ret_0_over JCN           .jj LDZ2 ADD2 get_bit ,&ret_0_set JCN           SWP2           .jj LDZ2 INC2 .jj STZ2          ,&loop JMP                 &ret_0_over POP2 POP2 POP2 #00 JMP2r          &ret_0_set POP2 POP2 #00 JMP2r      &done POP2 POP2 #01  JMP2r  @claim_alloc_sz_at_idx       #0000 .jj STZ2       &loop          DUP2 .jj LDZ2 SWP2 LTH2           ,&body JCN             ,&done JMP             &body          SWP2           DUP2 .jj LDZ2 ADD2 set_bit            .jj LDZ2 INC2 .jj STZ2          SWP2          ,&loop JMP       &done      POP2 POP2      JMP2r  @free_alloc_sz_at_idx        #0000 .jj STZ2       &loop          DUP2 .jj LDZ2 SWP2 LTH2           ,&body JCN           ,&done JMP           &body          SWP2           DUP2 .jj LDZ2 ADD2 clear_bit            .jj LDZ2 INC2 .jj STZ2          SWP2          ,&loop JMP       &done      POP2 POP2      JMP2r      @get_bit       DUP2       #03 SFT2        .byte_idx STZ2       #0007 SWP2 .byte_idx LDZ2 #30 SFT2 SUB2 SUB2      .bit_idx STZ2        .byte_idx LDZ2 N_PAGES #0001 SUB2 GTH2 ,&error_outside JCN      ;bitmap .byte_idx LDZ2 ADD2 LDA       .byte STZ      .byte LDZ .bit_idx LDZ2 NIP SFT #01 AND      JMP2r      &error_outside          ;outside-str print-str .byte_idx LDZ2 print16          BRK  @clear_bit       DUP2       #03 SFT2        .byte_idx STZ2       #0007 SWP2 .byte_idx LDZ2 #30 SFT2 SUB2 SUB2       .bit_idx STZ2        ;bitmap .byte_idx LDZ2 ADD2 LDA       .byte STZ       .bit_idx LDZ2 mask_clear       .byte LDZ SWP AND ;bitmap .byte_idx LDZ2 ADD2 STA  JMP2r  @set_bit       DUP2       #03 SFT2        .byte_idx STZ2       #0007 SWP2 .byte_idx LDZ2 #30 SFT2 SUB2 SUB2      .bit_idx STZ2        ;bitmap .byte_idx LDZ2 ADD2 LDA       .byte STZ      .bit_idx LDZ2 mask_set      .byte LDZ SWP ORA ;bitmap .byte_idx LDZ2 ADD2 STA  JMP2r  @mask_clear   .bit_idx STZ2 #ff [ #01 .bit_idx LDZ2 NIP #40 SFT SFT ] EOR  JMP2r  @mask_set   .bit_idx STZ2  #01 .bit_idx LDZ2 NIP #40 SFT SFT  JMP2r      @todo { 0005 "TODO 0a } STH2r print-str JMP2r  @print-bit #30 ADD #18 DEO JMP2r  @nl #0a18 DEO JMP2r  @ws #2018 DEO JMP2r  @print8              DUP       lonib       h2a       SWP       hinib       h2a       #18 DEO #18 DEO       JMP2r  @print16       SWP      print8      print8      JMP2r  @lonib       #0f AND      JMP2r  @hinib       #04 SFT      JMP2r  @h2a       DUP       #0a LTH       DUP       #01 SWP SUB       #57 MUL       SWP       #30 MUL       ADD       ADD       JMP2r      @print8-dec    DUP    DUP #64  LTH ,&d2 JCN   #64 DIV  DUP #30 ADD #18 DEO     #64 MUL SUB     DUP   &d2  DUP #0a  LTH ,&d3 JCN  #0a DIV  DUP #30 ADD #18 DEO     #0a MUL SUB    DUP   &d3  #30 ADD #18 DEO  POP  JMP2r        @print16-dec      DUP2       DUP2 #2710 LTH2 ,&d2 JCN            #2710 DIV2  DUP #30 ADD #18 DEO            #2710 MUL2 SUB2       DUP2       &d2      DUP2 #03e8  LTH2 ,&d3 JCN            #03e8 DIV2  DUP #30 ADD #18 DEO            #03e8 MUL2 SUB2        DUP2       &d3      DUP2 #0064  LTH2 ,&d4 JCN            #0064 DIV2  DUP #30 ADD #18 DEO            #0064 MUL2 SUB2       DUP2       &d4            #000a DIV2  DUP #30 ADD #18 DEO            #000a MUL2 SUB2  #30 ADD #18 DEO POP      JMP2r      @print-str       LDA2k       SWP2 #0002 ADD2 SWP2       DUP2             &loop      #0000 EQU2 ,&exit JCN       SWP2       LDAk #18 DEO       INC2 SWP2 #0001 SUB2 DUP2       ,&loop JMP      &exit      POP2 POP2 POP2      JMP2r    @invalid-str 000f "Invalid 20 "access:  @outside-str 0016 "Outside 20 "of 20 "page 20 "range:  @max-alloc-str 0021 "Max 20 "number 20 "of 20 "allocations 20 "reached      @PAGE_SZ  #0010 JMP2r   @N_PAGES  #0100 JMP2r   @DMEM_START  #f000 JMP2r   @MAX_N_ALLOCS  #0020 JMP2r   @n_allocs 0000  @allocated $80         @bitmap $40    |f000  @vmem   >
real 0.04
user 0.02
sys 0.01
            57556992  maximum resident set size
                   0  average shared memory size
                   0  average unshared data size
                   0  average unshared stack size
                3613  page reclaims
                 244  page faults
                   0  swaps
                   0  block input operations
                   0  block output operations
                   0  messages sent
                   0  messages received
                   0  signals received
                  15  voluntary context switches
                 405  involuntary context switches
           458886937  instructions retired
           159186232  cycles elapsed
            25759488  peak memory footprint
Possible error in comments, probably missing space around paren:
	bit_idx)

Error: <   |0000    @idx $2 @jj $2  @n_pages $2  @byte_idx $2  @bit_idx $2  @byte $1  |0100    test-mask_clear  test-mask_set  test-get_bit  test-clear_bit   test-set_bit   test-alloc_sz_is_free_at_idx  test-claim_alloc_sz_at_idx  test-free_alloc_sz_at_idx  test-malloc  test-free  BRK    @test-mask_clear       { 001d "Test 20 "for 20 "mask_clear(bit_idx) 0a } STH2r print-str      #0000 mask_clear  #fe EQU #30 ADD #18 DEO #0a18 DEO      #0001 mask_clear  #fd EQU #30 ADD #18 DEO #0a18 DEO      #0002 mask_clear  #fb EQU #30 ADD #18 DEO #0a18 DEO      #0003 mask_clear  #f7 EQU #30 ADD #18 DEO #0a18 DEO      #0004 mask_clear  #ef EQU #30 ADD #18 DEO #0a18 DEO      #0005 mask_clear  #df EQU #30 ADD #18 DEO #0a18 DEO      #0006 mask_clear  #bf EQU #30 ADD #18 DEO #0a18 DEO      #0007 mask_clear  #7f EQU #30 ADD #18 DEO #0a18 DEO  JMP2r  @test-mask_set       { 001b "Test 20 "for 20 "mask_set(bit_idx) 0a } STH2r print-str      #0000 mask_set  #01 EQU #30 ADD #18 DEO #0a18 DEO      #0001 mask_set  #02 EQU #30 ADD #18 DEO #0a18 DEO      #0002 mask_set  #04 EQU #30 ADD #18 DEO #0a18 DEO      #0003 mask_set  #08 EQU #30 ADD #18 DEO #0a18 DEO      #0004 mask_set  #10 EQU #30 ADD #18 DEO #0a18 DEO      #0005 mask_set  #20 EQU #30 ADD #18 DEO #0a18 DEO      #0006 mask_set  #40 EQU #30 ADD #18 DEO #0a18 DEO      #0007 mask_set  #80 EQU #30 ADD #18 DEO #0a18 DEO  JMP2r        @test-get_bit       { 0016 "Test 20 "for 20 "get_bit(idx) 0a } STH2r print-str      #01 ;bitmap #0001 ADD2 STA       #80 ;bitmap #0003 ADD2 STA       #02 ;bitmap #0004 ADD2 STA       #60 ;bitmap #0008 ADD2 STA       #04 ;bitmap #000c ADD2 STA       #20 ;bitmap #000d ADD2 STA       #0010 get_bit #00 EQU #000f get_bit #01 EQU AND print-bit nl      #0018 get_bit #01 EQU #0019 get_bit #00 EQU AND print-bit nl      #0026 get_bit #01 EQU #0027 get_bit #00 EQU AND print-bit nl      #0041 get_bit #01 EQU #0042 get_bit #01 EQU AND print-bit nl      #0065 get_bit #01 EQU #0066 get_bit #00 EQU AND print-bit nl      #006a get_bit #01 EQU #006b get_bit #00 EQU AND print-bit nl      #03 ;bitmap #0001 ADD2 STA       #c0 ;bitmap #0003 ADD2 STA       #06 ;bitmap #0004 ADD2 STA       #20 ;bitmap #0008 ADD2 STA       #0c ;bitmap #000c ADD2 STA       #30 ;bitmap #000d ADD2 STA       #0010 get_bit #00 EQU #000f get_bit #01 EQU AND print-bit nl      #0018 get_bit #01 EQU #0019 get_bit #01 EQU AND print-bit nl      #0026 get_bit #01 EQU #0025 get_bit #01 EQU AND print-bit nl      #0041 get_bit #00 EQU #0042 get_bit #01 EQU AND print-bit nl      #0064 get_bit #01 EQU #0065 get_bit #01 EQU AND print-bit nl      #006a get_bit #01 EQU #006b get_bit #01 EQU AND print-bit nl  JMP2r  @test-clear_bit       { 0018 "Test 20 "for 20 "clear_bit(idx) 0a } STH2r print-str      #000f clear_bit #000e clear_bit      #0018 clear_bit #0019 clear_bit      #0026 clear_bit #0027 clear_bit      #0041 clear_bit #0042 clear_bit      #0065 clear_bit #0066 clear_bit      #006a clear_bit #006b clear_bit      #000f get_bit #00 EQU #000e get_bit #00 EQU AND print-bit nl      #0018 get_bit #00 EQU #0019 get_bit #00 EQU AND print-bit nl      #0026 get_bit #00 EQU #0027 get_bit #00 EQU AND print-bit nl      #0041 get_bit #00 EQU #0042 get_bit #00 EQU AND print-bit nl      #0065 get_bit #00 EQU #0066 get_bit #00 EQU AND print-bit nl      #006a get_bit #00 EQU #006b get_bit #00 EQU AND print-bit nl  JMP2r  @test-set_bit       { 0016 "Test 20 "for 20 "set_bit(idx) 0a } STH2r print-str      #000f set_bit #000e set_bit      #0018 set_bit #0019 set_bit      #0026 set_bit #0027 set_bit      #0041 set_bit #0042 set_bit      #0065 set_bit #0066 set_bit      #006a set_bit #006b set_bit      #000f get_bit #000e get_bit EQU print-bit nl      #0018 get_bit #0019 get_bit EQU print-bit nl      #0026 get_bit #0027 get_bit EQU print-bit nl      #0041 get_bit #0042 get_bit EQU print-bit nl      #0065 get_bit #0066 get_bit EQU print-bit nl      #006a get_bit #006b get_bit EQU print-bit nl  JMP2r  @test-alloc_sz_is_free_at_idx       { 002f "Test 20 "for 20 "alloc_sz_is_free_at_idx(idx,alloc_sz) 0a } STH2r print-str         { 0006 "part1 0a } STH2r print-str       #000f #0001 alloc_sz_is_free_at_idx #00 EQU print-bit nl       #000f #0002 alloc_sz_is_free_at_idx #00 EQU print-bit nl       #000f #0004 alloc_sz_is_free_at_idx #00 EQU print-bit nl       #000f #0008 alloc_sz_is_free_at_idx #00 EQU print-bit nl       #000f #0010 alloc_sz_is_free_at_idx #00 EQU print-bit nl       { 0006 "part2 0a } STH2r print-str          #0010 #0001 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0010 #0002 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0010 #0004 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0010 #0008 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0010 #0010 alloc_sz_is_free_at_idx #00 EQU print-bit nl       { 0006 "part3 0a } STH2r print-str          #0011 #0001 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0011 #0002 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0011 #0004 alloc_sz_is_free_at_idx #01 EQU print-bit nl       #0011 #0008 alloc_sz_is_free_at_idx #00 EQU print-bit nl       #0011 #0010 alloc_sz_is_free_at_idx #00 EQU print-bit nl       { 0006 "part4 0a } STH2r print-str         #006c #0001 alloc_sz_is_free_at_idx #01 EQU print-bit nl      #006c #0002 alloc_sz_is_free_at_idx #01 EQU print-bit nl      #006c #0004 alloc_sz_is_free_at_idx #01 EQU print-bit nl      #006c #0008 alloc_sz_is_free_at_idx #01 EQU print-bit nl      #006c #0010 alloc_sz_is_free_at_idx #01 EQU print-bit nl  JMP2r  @test-claim_alloc_sz_at_idx       { 002d "Test 20 "for 20 "claim_alloc_sz_at_idx(idx,alloc_sz) 0a } STH2r print-str            ;bitmap LDA2 STH2       { 0006 "part1 0a } STH2r print-str      #0000 ;bitmap STA2        #0000 #0001 claim_alloc_sz_at_idx       ;bitmap LDA DUP print8 ws #80 EQU print-bit nl      #0001 #0002 claim_alloc_sz_at_idx       ;bitmap LDA DUP print8 ws #e0 EQU print-bit nl       #0003 #0003 claim_alloc_sz_at_idx       ;bitmap LDA DUP print8 ws #fc EQU print-bit nl       #0006 #0004 claim_alloc_sz_at_idx       ;bitmap LDA DUP print8 ws      ;bitmap INC LDA DUP print8 ws #ffc0 EQU2 print-bit nl       #000a #0005 claim_alloc_sz_at_idx       ;bitmap LDA DUP print8 ws      ;bitmap INC LDA DUP print8 ws #fffe EQU2 print-bit nl             STH2r ;bitmap STA2      { 0006 "part2 0a } STH2r print-str      #006c #0010 claim_alloc_sz_at_idx      #007c #0010 alloc_sz_is_free_at_idx #01 EQU print-bit nl      #006c #0010 alloc_sz_is_free_at_idx #00 EQU print-bit nl  JMP2r  @test-free_alloc_sz_at_idx        { 002c "Test 20 "for 20 "free_alloc_sz_at_idx(idx,alloc_sz) 0a } STH2r print-str      #006c #0010 free_alloc_sz_at_idx      #007c #0010 alloc_sz_is_free_at_idx print-bit nl      #006c #0010 alloc_sz_is_free_at_idx print-bit nl  JMP2r  @test-malloc  { 0014 "Test 20 "for 20 "malloc(sz) 0a } STH2r print-str  JMP2r  @test-free  { 0013 "Test 20 "for 20 "free(ptr) 0a } STH2r print-str  JMP2r    @reset      #00 .n_allocs STZ      #00 .error STZ         @get-error      .error LDZ       JMP2r        @alloc_sz_is_free_at_idx       #0000 .jj STZ2       &loop          DUP2 .jj LDZ2  SWP2 LTH2           ,&body JCN             ,&done JMP             &body           SWP2           DUP2 DUP2           .jj LDZ2 ADD2 N_PAGES #0001 SUB2 GTH2 ,&ret_0_over JCN           .jj LDZ2 ADD2 get_bit ,&ret_0_set JCN           SWP2           .jj LDZ2 INC2 .jj STZ2          ,&loop JMP                 &ret_0_over POP2 POP2 POP2 #00 JMP2r          &ret_0_set POP2 POP2 #00 JMP2r      &done POP2 POP2 #01  JMP2r  @claim_alloc_sz_at_idx       #0000 .jj STZ2       &loop          DUP2 .jj LDZ2 SWP2 LTH2           ,&body JCN             ,&done JMP             &body          SWP2           DUP2 .jj LDZ2 ADD2 set_bit            .jj LDZ2 INC2 .jj STZ2          SWP2          ,&loop JMP       &done      POP2 POP2      JMP2r  @free_alloc_sz_at_idx        #0000 .jj STZ2       &loop          DUP2 .jj LDZ2 SWP2 LTH2           ,&body JCN           ,&done JMP           &body          SWP2           DUP2 .jj LDZ2 ADD2 clear_bit            .jj LDZ2 INC2 .jj STZ2          SWP2          ,&loop JMP       &done      POP2 POP2      JMP2r      @get_bit       DUP2       #03 SFT2        .byte_idx STZ2       #0007 SWP2 .byte_idx LDZ2 #30 SFT2 SUB2 SUB2      .bit_idx STZ2        .byte_idx LDZ2 N_PAGES #0001 SUB2 GTH2 ,&error_outside JCN      ;bitmap .byte_idx LDZ2 ADD2 LDA       .byte STZ      .byte LDZ .bit_idx LDZ2 NIP SFT #01 AND      JMP2r      &error_outside          ;outside-str print-str .byte_idx LDZ2 print16          BRK  @clear_bit       DUP2       #03 SFT2        .byte_idx STZ2       #0007 SWP2 .byte_idx LDZ2 #30 SFT2 SUB2 SUB2       .bit_idx STZ2        ;bitmap .byte_idx LDZ2 ADD2 LDA       .byte STZ       .bit_idx LDZ2 mask_clear       .byte LDZ SWP AND ;bitmap .byte_idx LDZ2 ADD2 STA  JMP2r  @set_bit       DUP2       #03 SFT2        .byte_idx STZ2       #0007 SWP2 .byte_idx LDZ2 #30 SFT2 SUB2 SUB2      .bit_idx STZ2        ;bitmap .byte_idx LDZ2 ADD2 LDA       .byte STZ      .bit_idx LDZ2 mask_set      .byte LDZ SWP ORA ;bitmap .byte_idx LDZ2 ADD2 STA  JMP2r  @mask_clear   .bit_idx STZ2 #ff [ #01 .bit_idx LDZ2 NIP #40 SFT SFT ] EOR  JMP2r  @mask_set   .bit_idx STZ2  #01 .bit_idx LDZ2 NIP #40 SFT SFT  JMP2r      @todo { 0005 "TODO 0a } STH2r print-str JMP2r  @print-bit #30 ADD #18 DEO JMP2r  @nl #0a18 DEO JMP2r  @ws #2018 DEO JMP2r  @print8              DUP       lonib       h2a       SWP       hinib       h2a       #18 DEO #18 DEO       JMP2r  @print16       SWP      print8      print8      JMP2r  @lonib       #0f AND      JMP2r  @hinib       #04 SFT      JMP2r  @h2a       DUP       #0a LTH       DUP       #01 SWP SUB       #57 MUL       SWP       #30 MUL       ADD       ADD       JMP2r      @print8-dec    DUP    DUP #64  LTH ,&d2 JCN   #64 DIV  DUP #30 ADD #18 DEO     #64 MUL SUB     DUP   &d2  DUP #0a  LTH ,&d3 JCN  #0a DIV  DUP #30 ADD #18 DEO     #0a MUL SUB    DUP   &d3  #30 ADD #18 DEO  POP  JMP2r        @print16-dec      DUP2       DUP2 #2710 LTH2 ,&d2 JCN            #2710 DIV2  DUP #30 ADD #18 DEO            #2710 MUL2 SUB2       DUP2       &d2      DUP2 #03e8  LTH2 ,&d3 JCN            #03e8 DIV2  DUP #30 ADD #18 DEO            #03e8 MUL2 SUB2        DUP2       &d3      DUP2 #0064  LTH2 ,&d4 JCN            #0064 DIV2  DUP #30 ADD #18 DEO            #0064 MUL2 SUB2       DUP2       &d4            #000a DIV2  DUP #30 ADD #18 DEO            #000a MUL2 SUB2  #30 ADD #18 DEO POP      JMP2r      @print-str       LDA2k       SWP2 #0002 ADD2 SWP2       DUP2             &loop      #0000 EQU2 ,&exit JCN       SWP2       LDAk #18 DEO       INC2 SWP2 #0001 SUB2 DUP2       ,&loop JMP      &exit      POP2 POP2 POP2      JMP2r    @invalid-str 000f "Invalid 20 "access:  @outside-str 0016 "Outside 20 "of 20 "page 20 "range:  @max-alloc-str 0021 "Max 20 "number 20 "of 20 "allocations 20 "reached      @PAGE_SZ  #0010 JMP2r   @N_PAGES  #0100 JMP2r   @DMEM_START  #f000 JMP2r   @MAX_N_ALLOCS  #0020 JMP2r   @n_allocs 0000  @allocated $80         @bitmap $40    |f000  @vmem   >
real 0.03
user 0.02
sys 0.00
            57524224  maximum resident set size
                   0  average shared memory size
                   0  average unshared data size
                   0  average unshared stack size
                3860  page reclaims
                   0  page faults
                   0  swaps
                   0  block input operations
                   0  block output operations
                   0  messages sent
                   0  messages received
                   0  signals received
                   1  voluntary context switches
                 215  involuntary context switches
           444111502  instructions retired
           145020942  cycles elapsed
            25611864  peak memory footprint
